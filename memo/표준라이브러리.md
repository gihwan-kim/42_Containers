- 표준 라이브러리에서 제공하는 클래스, 함수는 std namespace 에 속한다.



# 1. 컨테이너

- 정보를 원소(element) 단위로 저장하는 컨테이너(container) 개념에 따라 구현했다.
- 데이터 구조의 종류마다 추가, 삭제, 접근연사의 처리 방식, 성능이 다르다.
- 표준 라이브러리에서 제공하는 컨테이너는 모두 'class template' 구조
- 컨테이너 인스턴스마다 타입 하나만 저장할 수 있음


### C++ 표준에서는 컨테이너, 알고리즘에 대해 '구현' 이아닌 '인터페이스' 만 정해두고있다.

> 구현과 인터페이스란 무엇을 의미할까? : 추상화를 통해 알 수 있다.
> 템플릿을 만들어두면 컴파일러에 따라 특정 타입에 맞게 틈플릿 코드를 생성한다?


# 추상화
- C++ 디자인에 사용되는 원칙
- 구현과 인터페이스를 분리한다.
    > 구현 : 작동원리, 원하는 작업을 달성하기 위해 작성한 코드
    > 인터페이스 : 작동법, 작성한 코드를 사용하기 위한 수단
        Ex.
        ```
        C 언어  : 라이브러리의 함수를 담은 헤더파일이 인터페이스 역할
        OOP     : 외부에서 접근할 수 있는 클래스의 프로퍼티, 메서드로 구성
        ```

- 내부 구현 방식, 알고리즘을 몰라도 코드를 사용할 수 있다.

### 외부에 공개할 인터페이스 결정
- 공개 범위를 public, private, protected 3 가지로 결정할 수 있다.
- protected 의 경우 하위 클래스, 동일한 클래스만 접근할 수 있다.
    > 같은 클래스인 객체들 또한 프로퍼티, 메서드에 접근할 수 있다.

- 어떤 항목을 public 으로 하냐에 따라 인터페이스를 어떤것들을 공개할지 정하는 것

### 추상화를 적용하여 디자인
- 함수, 클래스를 디자인할때 작성자 자신, 다른 사람들도 내부 구현사항을 몰라도 쉽게 사용할 수 있도록 구성해야한다.



### 컨테이너분류

1. 순차 컨테이너
    > vector
    > deque
    > list

2. 연관 컨테이너
    > map
    > multimap
    > set
    > multiset

3. 컨테이너 어댑터 
    > queue
    > stack

### 컨테이너의 원소
- 원소를 값으로 처리한다(value semantics)
    > 원소의 복제본을 생성 -> 대입 연산자로 대입 -> 소멸자로 원소 삭제
- 컨테이너에서 원소를 요청할 경우 저장된 복제본에 대한 reference 를 리턴

- 원소를 reference 로 처리하고 싶을 경우
    > 원소에 대한 포인터를 컨테이너의 요소로 저장한다.
- 템플릿 타입 매개변수 allocator
    > 원소에 대한 메모리를 할당하거나 해제할 수 있다. 


### iterator (반복자)
> (전문가를 위한 C++ P.767)
- 컨테이너의 종류가 달라도 iterator 의 인터페이스는 모든 C++ 표준을 따르기 때문에 모두 같다.
- 구체적인 동작은 달라도 컨테이너의 원소에 대해 반복문을 비숫한 방식으로 작성하도록 인터페이스 통일










# 2. 컨테이너 Vector

- <vector> 헤더파일
- 일련의 원소를 저장, 각 원소에 임의로 접근
- 원소를 추가할때마다 동적으로 크기가 증가한다.
- 동적 배열

### 분할 상환 상수 시간
- 마지막 항목을 추가하거나 삭제하는 연산을 매우 빠르게 처리
> 원소를 추가하는 시간이 분할 상환 상수 시간 (amortized constant time) 이다
    > 추가 연산을 수행하는데 O(1) 시간 정도 걸린다

- vector 는 원소가 추가되면 크기도 늘어나기 때문에 공간 복잡도는 O(N)

### 끝 부분이 아닌 다른 지점에 원소를 추가 삭제하는 연산
- O(1) 보다 느린 선형시간(linear time)이 걸린다.
- 추가, 삭제할때 한칸식 이동하기 떄문


### 연결리스트 같은 데이터 구조보다 Vector 가 더 빠르다.
- 메모리가 연속된 구조이기 때문
    > 컴퓨터는 연속된 메모리 구조를 더 효율적으로 처리한다.





# 3. 컨테이너 List
- 양방향(이중) 연결 리스트
- 배열, vector 처럼 일련의 원소를 저장하지만 연속된 메모리 공간에 저장되지 않을 수 있다.
- list 의 원소마다 앞, 뒤에 있는 원소에 대한 위치 정보가 저장돼있다. (주로 포인터)


# 4. 컨테이너 Queue
- 사람 또는 물체가 한 줄로 서있다는 뜻의 영단어와 동일
- FIFO : First-In First-Out
- 항상 한쪽 끝에서만 원소를 추가한다.
- 다른 쪽 끝에서는 꺼내기만한다.

> 줄을 서서 기다리는 상황과 동일



# 5. 컨테이너 Stack
- LIFO (마지막에 들어온게 먼저나간다.) or FILO(먼저들어온게 늦게 나간다.)


# 6. 컨테이너 Map
- 연관 배열을 표현
- 모든 타입으로 인덱스를 표현할 수 있는 배열을 만들 수 있다.
    > 원래는 정수가 인덱스 였다면 string 을 인덱스로 할 수있다.
- operator[] 제공
- key/value 로 원소를 저장할떄 주로 사용



# 제너릭 프로그래밍
- 데이터 형식에 의존하지 ㅏㄴㅎ고 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 둔다.
- 재사용성을 높인다.
> 템플릿 같은 기능



#